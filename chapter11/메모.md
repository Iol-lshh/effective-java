
직렬화란 뭘까요?

자바가 객체를 바이트스크림으로 인코딩하고, 바이트 스트림으로부터 다시 객체를 재구성하는 메커니즘을 직렬화 > 역직렬화라고합니다.
직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장할 수 있다. 그래서 저장한 객체를 나중에 다시 JVM으로 불러와 역직렬화할 수 있다.

https://ko.wikipedia.org/wiki/%EC%A7%81%EB%A0%AC%ED%99%94


**아이템 85**

- 범용적인 데이터 포맷이 널리 사용되기전에는 직접 객체를 주고받을 방법이 필요했다.
- 그때 나온 방법이 직렬화/역직렬화를 통해 분산객체(RMI나 바이트스트림으로 직접 자바 객체를 주고 받는것)를 주고받는 것이었다.
	- 하지만 이 방식은 문제가 많았다.
	- 바이트로 값이 들어오기때문에 어떤 보안 공격이 들어올지 모른다.
	- 역직렬화에서 위험한 동작을 수행하는 메서드들을 가젯이라 부른다.
	- 사실 가젯까지 갈 것도 없이 복잡한 객체를 잘못 역직렬화했다간 프로그램이 영원히 역직렬화하고 있을 수도 있다.
	- 그 예시로 Hash값을 다루는 HashSet의 경우 안에 HashSet이 들어간다면 해시코드를 계산해야하느라 기하급수적으로 계산과정이 길어진다.
- 그러면 문제를 어떻게 대처해야할까?
	- 바이트 스트림을 역직렬화하지 말자.
	- 요즘와서는 직접 자바 직렬화를 해야할 이유가 없다.
- 직렬화 대신 **크로스-플랫폼 구조화된 데이터 표현**을 사용하자.
	- 얘네들은 임의 객체 그래프를 직렬화/역직렬화하는 대신
	- 속성-값으로 된 데이터 객체를 기본타입/배열타입으로 직렬화한다.
	- 이게 우리가 아는 Json이다. (프로토콜 버퍼라는 것도 있음)
- 만약 레거시 시스템의 경우는
	- 신뢰할 수 없는 데이터면 역직렬화하지 말자. (누구든 호출할 수 있는 API에 역직렬화 달아두지 말자.)
	- 이것도 피할 수 없다면 역직렬화 필터링(ObjectInputFilter, 자바9에서 지원)을 사용하자.
	- 역직렬화 필터링은 블랙리스트(거부할 클래스 지정)와 화이트리스트(받아들일 클래스 지정) 방식을 지원하는데 화이트리스트 방식을 추천한다.
	- 그래도 직렬화 폭탄은 걸러내지 못한다.
- 결론, 이제와선 자바 객체를 직접 바이트스트림으로 역직렬화하는 방식은 추천되지 않는다. 데이터포맷을 사용하는게 보안상 이점이 더 많다.

**아이템 86**
- Serializable을 구현하면 릴리스 뒤 수정하기 어렵다.
	- Serializable로 직렬화된 자바 클래스를 직접 제공한다면 공개하려고하지 않았던 private 필드까지 전부 공개하는 꼴이다.
	- 그리고 데이터 타입이나 변수명까지 직렬화해준셈이기 때문에 마음대로 리팩토링하면 버전간 호환이 깨질 수 있다. (private int x;이랑 private long x;는 다른거니까)
	- 이런식으로 역직렬화 호환성을 계속 고려해야하니까 Serializable를 붙이는건 신중해야한다.

- Serializable가 문제가 되는 경우를 자세히 알려주겠다.
	- 스트림 고유 식별자를 고려하지않은 케이스 > 모든 직렬화된 클래스는 고유한 식별 번호(UID)를 부여받는다. 이를 직렬화 클래스내에서 직접 명시하지 않으면 런타임에 자동 부여 된다.
	  이 값은 클래스 이름, 구현 인터페이스 등등 클래스 멤버들을 고려해서 부여하기 때문에 하나라도 수정된다면 직렬 버전 UID값이 바뀌어버린다. 그로인해 호환성이 깨져 InvalidClassException이 발생하게 된다.
	- 이전 아이템 85에서 말했듯이 버그와 보안 구멍이 생길 위험이 높아진다.
	  자바내에서 객체는 생성자를 사용해 만드는게 기본이다. 하지만 직렬화는 이러한 기본 메커니즘을 우회한채로 객체를 생성한다. 그렇기때문에 불변식 깨짐과 허가되지않은 접근에 쉽게 노출되기도 한다.
	- 해당  클래스의 신버전을 릴리스할때 테스트 포인트가 늘어난다. 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 뒤 구버전으로 역직렬화가 가능한지, 반대도 가능한지 검사해야한다. (이를 방지하고 싶으면 커스텀 직렬화 형태를 잘 설계해놓아야한다.)

- Serializable을 써야하는 상황?
	- Seriazliable을 반드시 구현해야하는 다른 클래스의 컴포넌트로 쓰일 클래스는 Seriazliable을 구현해야겠지..
	- 보통은 BigInteger나 Instant 같은 값 클래스나 컬렉션 클래스들이 Seriazliable을 구현하고
	- 스레드 풀 같은 동작하는 객체를 표현하는 클래스들은 구현하지 않는다.
- 하지만 상속용으로 설계된 클래스는 Seriazliable을 구현하면 안되고, 인터페이스도 Seriazliable을 확장하면 안된다.
	- 왜냐? 해당 클래스나 인터페이스를 확장하거나 구현하는 클래스들도 줄줄이 그걸 확장해야하니까..


- 그럼에도 할거라면 커스텀 직렬화를 해야한다.
	- 이때 직렬화 가능 클래스를 만들거면 고품질의 직렬화 형태또한 주의해서 설계해야한다. (다음 아이템에 나올 예정)
	-  **`writeObject()` / `readObject()` 메서드**를 재정의하면, **직렬화 시 어떤 정보를 어떻게 바이트 스트림에 넣을지** 직접 결정할 수 있다.
###### 분산객체
분산 객체(Distributed Object)는 **네트워크를 통해 다른 시스템에 존재하는 객체를 의미**합니다. RMI나 웹 서비스(REST API) 등이 분산 객체 기술에 해당합니다.
###### +) 덧붙임
직렬화는 분산객체를 만들 수 있다 > **분산 객체**는 서로 다른 프로세스나 머신에 분산된 객체를 하나의 응용 프로그램 내의 객체처럼 다룰 수 있게 해주는 기술
1. **클라이언트**가 `sayHello("ChatGPT")`를 호출함
2. Java RMI 런타임이 내부적으로 **직렬화(Serialization)**를 통해 “메서드 이름·매개변수” 등의 정보를 네트워크로 전송
3. **서버**의 RMI 런타임이 이를 **역직렬화(Deserialization)**하여, 실제 `HelloServiceImpl` 객체의 `sayHello("ChatGPT")` 메서드를 호출
4. 메서드 결과(`"Hello, ChatGPT from Remote Object!"`)를 다시 직렬화해 네트워크로 전송
5. 클라이언트는 이를 받아서 **역직렬화**하고, 결과 문자열을 리턴받음

> 즉, **코드는 내 로컬에서 객체 메서드를 부르는 것 같아 보이지만**, 실제로는 다른 머신(또는 다른 프로세스)에서 메서드가 실행되고 결과만 가져오는 구조가 “원격 객체 호출(Remote Object Invocation)”입니다.


