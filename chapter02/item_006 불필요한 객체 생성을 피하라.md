똑같은 기능의 객체를 매번 생성하는 것보단 객체 하나를 재사용하는 편이 나을때가 많다.

재사용하지 않는 극단적으로 나쁜 예시는 아래와 같다.

```java
String s = new String("nonono!");
```

자세히 보면 해당 코드는 실행될때마다 String 인스턴스를 새로 만든다.

생성자에 넘겨진 “nonono!” 자체가 이 생성자로 만들어내려는 String과 기능적으로 완전히 똑같다. 쓸데없이 String 인스턴스를 수백개 만들 수도 있는 셈이다. (정확히는 문자열 리터럴도 만들고, new String()에 의해 새롭게 힙에 또 추가되는 셈이다)

```java
String s = "nonono!";
```

이렇게 하면 매번 새로운 String 인스턴스를 만드는 대신 하나의 String 인스턴스를 사용한다. 또한 같은 가상 머신 안에서 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 사용함이 보장된다.

*ps) 여기서 잠깐! 저 둘이 무슨 차이지?*

일단 String 인스턴스를 새로 만들면 메모리에 뭔가 추가적으로 할당된단 얘기같긴한데, 그렇다면 기존엔 어떻게 동작하고 있던거지?

문자열 리터럴이란 우선 소스코드내에서 직접 입력된 문자열 값을 말한다. Java에선 문자열 리터럴을 문자열 풀을 통해 관리하는데, 이는 JVM 힙 메모리 영역내에 존재한다.

간단하게 동작 방식을 설명하자면 똑같은 텍스트일땐 JVM이 문자열 풀에서 해당 텍스트가 이미 존재한다면 해당 객체를 반환하기 때문에 추가적인 메모리 할당이 이루어 지지않기에 메모리 측면에서 효율적이다.

```java
String s1 = "text";
String s2 = "text";
System.out.println(s1 == s2); // true, 같은 참조를 가리킴
```

위의 예에서 s1과 s2는 동일한 문자열 리터럴 "text"를 참조하므로, == 연산자로 비교했을 때 true가 반환된다. 두 변수가 문자열 풀에서 동일한 객체를 가리키고 있기 때문이다.

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다. 생성자는 호출할 때마다 새로운 객체를 만들지만 팩터리 메서드는 전혀 그렇지 않다. 가변객체도 마찬가지다. 사용중에 변경되지 않음이 보장된다면 재사용할 수 있다.

그렇다면 **생성 비용이 비싸 재사용해야하는 예시**는 뭐가 있을까?

(사실 이 경우는 제대로 따져보지 않는 이상 알기 어렵다)

```java
static boolean isRomanNumeral(String s){
	return s.matches("^[A-Z]*$");
}
```

String.matchs는 정규표현식으로 문자열을 확인한다. String.matchs는 내부에서 정규표현식용 Pattern인스턴스를 만드는데 위의 코드의 경우 해당 인스턴스는 한번만 쓰이고 곧바로 가비지 컬렉션 대상이 된다.

성능을 개선하려면 정규표현식을 표현하는 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 해당 인스턴스를 재사용하면 된다.

```java
// 정규 표현식을 미리 컴파일하여 static final 필드에 저장
  private static final Pattern PATTERN = Pattern.compile("^[A-Z]*$");

  public static boolean isRomanNumeral(String s) {
      return PATTERN.matcher(s).matches();
  }
```

*(생성 비용이) 값비싼 객체를 매번 생성하지 않고 재사용해 성능을 개선했다!*

객체가 불변이라면 재사용해도 안전하다. 하지만 직관적으로 그렇지 않은 상황도 있다. *(이 얘기는 갑자기 왜?)*

어댑터 패턴을 생각해보자. 어댑터 패턴의 경우 실제 작업은 뒷단 객체에 위임하고 본인은 인터페이스 역할을 한다.

어댑터는 내부에 상태를 가지고 있으며, 이 상태를 관리하고 타겟 인터페이스에 맞게 변환하는 역할을한다. 어댑터가 내부 상태를 변경하면 외부에서는 이를 명확히 인지하기 어려울 수 있다.

```markdown
Target(타겟): 클라이언트가 사용하고자 하는 특정 인터페이스를 정의합니다.
Adaptee(어댑티): 기존에 존재하는 인터페이스로, 어댑터가 이 인터페이스를 타겟 인터페이스로 변환해야 합니다.
Adapter(어댑터): 타겟 인터페이스를 구현하면서, 내부적으로 어댑티의 인스턴스를 갖고 있어 그 기능을 사용합니다.
```

오토 박싱 또한 불필요한 객체를 만들어 낸다. 오토 박싱은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 걸 말한다. **오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주나, 완전히 없애주는 건 아니다.** 정확히는 성능상에서 그렇지 않다.

```java
private static long sum(){
	Long sum = 0L; // 정확히 이 부분이 문제다!
	for (long i=0; i<=Integer.MAX_VALUE; i++) sum+= i;
	return sum;
}
```

sum 변수를 Long으로 선언해서 long 타입인 i가 sum에 더해질때마다 Long으로 변환해주어야해서 속도가 느렸을거다. **박싱된 기본 타입보다는 기본 타입을 사용하고 의도치 않은 오토 박싱을 사용하지 않도록 주의하자!**

결론은 객체 생성은 비싸니 피해야한다가 아니다. 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가 생성하는 건 괜찮다. 단지 의도치 않은 객체 생성을 지양하자는 얘기다.

그렇다고 단순한 객체 생성을 피하고자 객체 풀같은걸 매번 만들어 오버엔지니어링 하진 말자.(DB연결에선 사용하는게 맞다) 하지만 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 되려 성능을 떨어뜨린다.

**기존 객체를 재사용하는 것보다 새로운 객체가 무조건 만들어져야하는 케이스(방어적 복사가 필요한 상황)를 고려하는 게 더 중요한 순간도 있다.** 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 주지만 방어적 복사가 필요한 상황에서 재사용을 하게되면 보안 구멍과 버그를 만들 수도 있다는 점을 알아야 한다.