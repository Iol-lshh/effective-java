
### 성능을 높이겠다고 최악으로 짠 최악의 코드

```java
try {
    int i = 0;
    while (true) range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {

}
```

이 코드는 배열의 원소를 순회하다가 배열 끝에 도달하면 예외를 발생시켜 반복문을 종료하는 방식이다.  
사실 이 코드는 아래와 같은 **알아보기 쉬운 코드**로 충분히 표현할 수 있다.

```java
for (Mountain m : range) m.climb();
```

그럼에도 예외를 써서 루프를 종료한 이유는 뭘까?  
이 코드를 작성한 사람은 **JVM이 배열에 접근할 때마다 경계를 검사**하니, 반복문에서 이러한 경계 검사 과정을 줄이고자 했던 것이다.

하지만 이러한 추론은 다음 세 가지 면에서 잘못되었다.

1. **예외는 예외 상황에 쓰라고 설계되었다.**  
    일상적인 제어 흐름에서 사용할 경우 실제로 빠를지 확신할 수 없다. 예외는 일반적인 제어 흐름에서 최적화되는 것을 목표로 하지 않았기 때문이다.
2. **코드를 `try-catch` 블록에 넣으면 JVM이 할 수 있는 최적화가 제한된다.**  
    컴파일러가 예외 처리를 위해 추가적인 메타데이터를 생성하므로, JIT 컴파일러가 명령어를 재배치하거나 루프를 풀어내는 최적화를 수행하기 어려워진다.
3. **배열을 순회하는 표준 관용구는 중복 검사를 수행하지 않는다.**  
    JVM이 이미 내부적으로 최적화를 수행하므로 걱정할 필요가 없다.

결과적으로 성능을 높이겠다고 한 이 접근은 실제로는 성능을 더 느리게 만든 셈이다.

---

### 예외는 예외 상황에만 써야 한다

1. **예외는 오직 예외 상황에서만 사용해야 한다.**  
    일상적인 제어 흐름에 예외를 사용하는 것은 잘못된 설계다.
    
2. **잘 설계된 API는 정상적인 제어 흐름에서 예외를 사용하지 않도록 설계해야 한다.**
    - 특정 상태에서만 호출 가능한 **상태 의존적 메서드**를 제공할 경우, 반드시 **상태 검사 메서드**도 함께 제공하자.
        - 예: `Iterator` 인터페이스의 `hasNext`(상태 검사)와 `next`(상태 의존)

---

### 왜 `try-catch` 블록이 JVM 최적화를 방해할까?

- **추가 메타데이터**: `try-catch` 블록은 컴파일러가 예외 처리를 위해 바이트코드에 추가 정보를 포함한다.
- **명령어 재배치 제한**: JVM은 명령어 순서를 바꾸거나 루프를 풀어 성능을 높이지만, `try-catch` 블록이 있으면 이 최적화가 어렵다.
- **보수적 최적화**: JIT 컴파일러는 예외 발생 가능성을 고려해 최적화를 제한적으로 수행한다.

---

### 상태 검사 메서드 vs 옵셔널 vs 특정 값 반환

상태 검사 메서드 대신 사용할 수 있는 선택지로는 **빈 옵셔널**이나 **특정 값 반환**이 있다. 어느 방법을 사용할지는 다음을 기준으로 결정하자.

1. **외부 요인으로 상태가 변할 가능성이 있는 경우**
    - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있다면 옵셔널이나 특정 값을 사용하자.
    - 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 상태가 변할 수 있기 때문이다.
2. **성능이 중요한 경우**
    - 상태 검사 메서드가 상태 의존적 메서드의 작업을 중복 수행한다면 옵셔널이나 특정 값을 반환하는 방식이 더 나을 수 있다.
3. **그 외의 경우**
    - 상태 검사 메서드 방식이 조금 더 낫다.
    - 가독성이 좋고, 잘못 사용했을 때 버그를 발견하기 쉽다. (상태 검사 메서드 호출을 빼먹으면 상태 의존적 메서드가 예외를 던지기 때문이다.)

### 결론

- **예외는 예외 상황에만 써야 한다.**  
    정상적인 제어 흐름에서 예외를 사용하는 것은 지양하자.
- **잘 설계된 API는 예외를 사용하지 않도록 설계하자.**  
    정상적인 제어 흐름은 상태 검사 메서드와 상태 의존적 메서드의 조합으로 처리하자.
