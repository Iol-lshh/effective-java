
### 마커 인터페이스과 마커 애너테이션

마커 인터페이스는 이전에 아이템 13에서 언급했듯이, 딱히 메소드는 없지만 특정 로직을 수행할때 클래스의 타입 체크만을 위한 인터페이스를 말한다.
```java
public interface Cloneable {
}
```

마커 애너테이션도 마커 인터페이스 처럼 자체로는 특별한 기능을 수행하지 않지만 의미 부여를 위해 사용하는 애너테이션이다.(사실 애너테이션이라기보단 이전에 언급했듯이 데코레이터에 가깝긴 하다.)
```java
@Deprecated
    void oldMethod() { // 삭제되었다고 알려주기만 할 뿐, 딱히 기능은 없음
        System.out.println("This method is deprecated.");
    }
```

### 마커 인터페이스가 더 나은점

**마커 인터페이스는 구현한 클래스의 인스턴스들을 구분 타입으로 쓸 수 있다.**
- 마커 인터페이스는 특정 타입을 나타내는 구분자로 사용될 수 있기 때문에 해당 인터페이스를 구현한 클래스들은 컴파일 타임에 타임 안정성이 검증된다.
- 하지만 마커 애너테이션은 타입 검증 기능이 없다! 런타임에 리플렉션을 통해 확인하기 때문에 인터페이스를 쓰면 런타임에 발견될 오류를 컴파일에서 발견할수 있다.

**마커 인터페이스는 적용대상을 더 정밀하게 지정할 수 있다.**
- 특정 조건을 갖춘 클래스들만 어떤 기능을 수행하거나 타입 안정성을 보장하고 싶을땐 구조적으로 마커 인터페이스가 적합하다.
- 예를 들어서 특정 인터페이스를 구현한 클래스에만 적용하고 싶은 로직이 있다면 해당 클래스에서만 특정 인터페이스를 구현하면 된다. (이렇게 하면 하위 타입임이 보장된다.)

**마커 애너테이션이 더 나은 점**
- 거대한 애너테이션 시스템의 지원을 받는다.

**마커 인터페이스를 잘못 구현한 예시도 있다.**
대표적으로 ObjectOutputStream.writeObject임
```java
public final void writeObject(Object obj) throws IOException {
    if (enableOverride) {
        writeObjectOverride(obj);
        return;
    }
    try {
        writeObject0(obj, false);
    } catch (IOException ex) {
        if (depth == 0) {
            writeFatalException(ex);
        }
        throw ex;
    }
}
```
Serializable 타입을 받는게 아닌 Object 객체를 받고있다. 마커인터페이스의 타입 검사 이점을 못살리는 셈이다.

### 결론
- 파라미터로서 활용하거나 반환 타입으로서 활용하는 등 타입으로 쓸 목적이 있다면, 마커 인터페이스를 쓰자
- 프레임웍에서 애너테이션을 적극 활용한다면 마커 애너테이션을 쓰자
    - `ElementType.TYPE` (클래스,인터페이스 적용 타입이라면) 인 마커 애너테이션을 작성하고 있다면, 마커 인터페이스를 고려해보자.
