

### `Serializable`을 구현하면 릴리스 뒤 수정이 어렵다

1. **비공개(`private`) 필드 노출**
    
    - 직렬화된 클래스는 클래스의 **모든 필드**를 직렬화 형태로 공개한다.
    - `private` 필드까지 바이너리 형태로 외부에 노출되어, 완전한 은닉이 어려워진다.
2. **버전 간 호환성 문제**
    
    - 직렬화된 클래스에는 **고유 식별자(`serialVersionUID`)**가 부여된다.
    - 클래스의 필드 타입이나 이름을 바꾸면 UID가 달라져 **역직렬화에 실패**(`InvalidClassException`)할 수 있다.
    - 사소한 변경에도 UID가 변경될 수 있어, 이전 버전 데이터와 호환이 깨진다.
3. **직렬화 호환성 유지 부담**
    
    - 새 버전을 릴리스할 때마다 **이전 버전과의 직렬화 호환성**을 테스트해야 한다.
    - 예: 구버전 → 신버전 역직렬화, 신버전 → 구버전 역직렬화 모두 확인 필요.
    - 이로 인해 **테스트 포인트**가 기하급수적으로 늘어난다.

### `Serializable`로 인해 발생하는 더 심각한 문제들

1. **보안 구멍**
    
    - 직렬화는 **생성자를 거치지 않고** 바이트 스트림만으로 객체를 복원한다.
    - 이 과정에서 불변식(invariant)이 깨지거나, 예기치 못한 접근이 일어날 수 있다.
    - 이전 아이템(Item 85)에서 다룬 역직렬화 공격(가젯, 직렬화 폭탄 등)도 여전히 유효하다.
2. **릴리스 후 유지보수성**
    
    - 직렬화 가능 클래스를 수정할 때마다 **직렬화 호환성**을 고민해야 하고,
    - 필드나 구조 변경이 자유롭지 않아 **리팩터링**이 어렵다.
3. **테스트 범위 증가**
    
    - 새 버전을 낼 때마다, “신버전 ↔ 구버전” 간 역직렬화 테스트를 모두 해야 한다.
    - 이를 소홀히 하면, 일부 사용자 환경에서 **데이터 불일치**나 **예외**가 발생한다.

### 3. `Serializable`을 구현해야 하는 예외적 상황

1. **직렬화를 강제하는 상위 클래스·인터페이스**
    
    - 예: 특정 프레임워크나 라이브러리가 `Serializable` 구현을 요구해 선택의 여지가 없는 경우.
2. **값 클래스(Value Class)**
    
    - 예: `BigInteger`, `Instant` 등 **불변(immutable)** 객체.
    - 복잡한 자원이나 실행 상태를 다루지 않는 순수 데이터 클래스이므로 비교적 안전하게 직렬화를 지원할 수 있다.
3. **‘동작하는 객체’**(예: 스레드 풀, 소켓 등)는 일반적으로 직렬화하지 않음
    
    - 상태가 복잡하고 운영체제 자원과 맞물려 있어 호환성과 보안 문제가 크기 때문이다.

### **상속용 클래스나 인터페이스**는 직렬화를 구현하지 말자

1. **직렬화 요구가 하위 클래스까지 전이**
    
    - 상위 클래스(또는 인터페이스)가 `Serializable`을 구현하면, 이를 상속·구현하는 클래스들도 모두 직렬화 호환성을 유지해야 한다.
    - 설계 자유도가 떨어지고, 불필요한 부담이 발생한다.
2. **직렬화도 하고 확장성도 갖춰야 한다면?**
    - 인스턴스 필드 중 **불변식**이 중요한 값이 있다면, 하위 클래스에서 `finalize()`를 재정의할 수 없게 막는다.
    - **기본값으로 초기화되면 안 되는 필드**가 있다면, `readObjectNoData()` 메서드에서 해당 필드를 적절히 초기화한다.

### `readObjectNoData` 메서드

인스턴스 필드 중 기본값 중 초기화되면 안되는 값이 있다면 `readObjectNoData` 메서드를 추가해야한다. `readObjectNoData` 메서드는 자바 4부터 추가되었고, 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드이다.

**`readObjectNoData`** 메서드는 직렬화(Serialization) 과정에서 “읽을 데이터가 전혀 없는 상황(no data)”을 처리하기 위한 메서드이다. 역직렬화(Deserialization) 시에 스트림에 해당 클래스의 데이터가 전혀 없는 경우에 호출된다.

```java
private void readObjectNoData() throws InvalidObjectException {
        throw new InvalidObjectException("스트림 데이터가 필요합니다");
    }
```

- 예를 들어, **상위 클래스**가 직렬화를 지원하지 않다가, 새 버전에서 갑자기 직렬화를 지원하도록 변경됐을때
- 기존에 직렬화된 데이터에는 상위 클래스 정보가 포함되지 않았으므로, 역직렬화 과정에서 “읽을 데이터가 없음(no data)” 상태가 될 수 있다.
- `readObjectNoData()`가 있으면, 그 안에서 **기본값을 설정하거나 예외를 던지는 식으로** 대응할 수 있다.

### 하위 클래스가 직렬화를 지원하려 할 때, 상위 클래스가 직렬화를 지원하지 않으면?

1. **매개변수 없는 생성자 필요**
    - 역직렬화 시 상위 클래스에서 `public` 혹은 `protected` 기본 생성자가 있어야 한다.
    - 없다면 ‘직렬화 프록시 패턴’ 등 복잡한 우회 방법을 써야 한다.
2. **내부 클래스(Inner Class)는 직렬화 비추**
    - 내부 클래스에는 바깥 객체 참조, 지역 변수 정보 등을 컴파일러가 자동으로 추가한다.
    - 직렬화 형태가 불안정해 호환성 유지가 어렵다.
    - 반면 정적 멤버 클래스(`static class`)는 이러한 문제가 없어 비교적 직렬화가 안전하다.

### **결론**

- 한 번 `Serializable`을 구현하면 **릴리스 후 버전 호환성과 보안** 문제를 계속 떠안아야 한다.
- 값 타입(불변 클래스) 같이 단순한 구조가 아니라면, **직렬화를 피하는 편**이 유지보수 및 안전성 면에서 훨씬 유리하다.
- 특히 **상속용 클래스나 인터페이스**에 `Serializable`을 붙이면, **하위 클래스 전반**에 직렬화를 강제하므로 더 신중해야 한다.
- 자바 직렬화가 꼭 필요하다면, 직렬화 프록시 패턴 혹은 커스텀 직렬화(`readObject`, `writeObject`, `readObjectNoData` 등)를 사용하고, 버전 간 호환성을 철저히 관리하도록 하자.